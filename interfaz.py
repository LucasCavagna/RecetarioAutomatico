# -*- coding: utf-8 -*-
"""Interfaz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k96OoJWGLvH_9Gq1k8VmMCBcFIUK1koV
"""

! pip install gradio
! pip install requests pillow
! pip install gspread pandas oauth2client

# Cargar librerias
import gradio as gr
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from google.colab import drive
import tensorflow as tf
import cv2
import requests
import pandas as pd
import os
from pathlib import Path

"""# Interfaz del usuario

En esta sección se encuentran las funciones encargadas de preparar la interfaz del usuario de manera que sea intuitivo y fácil probar el modelo y así obtener las recetas acordes a las piezas que posee el usuario.
"""

# Lista de categorías
categorias = [
    "compuerta", # 0
    "cuadrado", # 1
    "cuadradoHueco", #2
    "parrilla", # 3
    "puente", # 4
    "rectangulo", # 5
    "trianguloEquilatero", # 6
    "ventana", # 7
    "trianguloIsoceles" # 8
]

# URL de la hoja de cálculo pública con recetas e imágenes
SHEET_URL = "https://docs.google.com/spreadsheets/d/1P3243HTawFnnbHUxPQCwTGyP9cMr8hO8/edit?usp=sharing&ouid=109156331046017853018&rtpof=true&sd=true"

# URL del modelo en GitHub
NR_URL = "https://github.com/camiVK/PDI/raw/34d2401692d07f7a8349acd431b7fd3c81104ef0/recetario.keras"
LOCAL_MODEL_PATH = Path("recetario.keras")

def download_model(url: str, local_path: Path):
    # Descarga el modelo si no existe en la ruta local
    if local_path.exists():
        print(f"El modelo ya está en {local_path}")
        return

    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with local_path.open("wb") as f:
            for chunk in r.iter_content(chunk_size=8192):
                f.write(chunk)
                f.flush()  # Asegura escritura inmediata en disco

# Descarga el modelo
download_model(NR_URL, LOCAL_MODEL_PATH)

# Carga y compila el modelo
new_model = tf.keras.models.load_model(LOCAL_MODEL_PATH)
new_model.compile(loss=tf.keras.losses.CategoricalCrossentropy(), optimizer="adam", metrics=["accuracy"])

# Estados globales
state_images = []
state_parts = []
diccionario_datos = {}
diccionario_enlaces = {}

def filtrar_diccionario_por_numeros(lista_numeros, diccionario_datos):
    # Se devuelven los nombres de las recetas que cumplen con las condiciones
    return [
        nombre for nombre, numeros in diccionario_datos.items()
        if all(a >= int(b) for a, b in zip(lista_numeros, numeros))
    ]

def filtrar_diccionario_por_numeros_laxa(lista_numeros, diccionario_datos):
    # Función similar a la anterior, solo que permite que no se tengan
    # las piezas exactas, sino sustituciones de las piezas cuadradas
    recetas_filtradas = []
    indices_exactos = [4, 5, 6, 8]
    indices_laxos = [0, 1, 2, 3, 7]

    # Búsqueda exacta
    for nombre, numeros in diccionario_datos.items():
        if all(lista_numeros[i] >= int(numeros[i]) for i in indices_exactos) and \
           sum(lista_numeros[i] for i in indices_laxos) >= sum(int(numeros[i]) for i in indices_laxos):
            recetas_filtradas.append(nombre)

    return recetas_filtradas


def diccionario_y_enlaces(sheet_url):
    # Genera dos diccionarios a partir de la hoja de cálculos pública
    # Un diccionario corresponde a las recetas con la cantidad de piezas necesarias
    # El otro diccionario guarda los enlaces de las fotos de cada receta
    csv_url = sheet_url.replace("/edit?usp=sharing", "/export?format=csv")

    # Leer los datos en un DataFrame
    df = pd.read_csv(csv_url)

    # Extraer datos y enlaces
    diccionario_datos = df.iloc[:-1, :].astype(str).to_dict(orient="list")
    diccionario_enlaces = df.iloc[-1, :].to_dict()

    return diccionario_datos, diccionario_enlaces

diccionario_datos, diccionario_enlaces = diccionario_y_enlaces(SHEET_URL)

def abrir_imagen_desde_enlace(url):
    # Descarga y abre una imagen desde un URL.
    try:
        response = requests.get(url, stream=True)
        response.raise_for_status()

        # Convertir los datos en una imagen
        image_array = np.frombuffer(response.content, dtype=np.uint8)
        img = cv2.imdecode(image_array, cv2.IMREAD_COLOR)

        if img is None:
            print("Error: No se pudo decodificar la imagen.")
            return None

        return cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    except requests.RequestException as e:
        print(f"Error al descargar la imagen: {e}")
        return None

# Recopilador de imagenes

def process_inputs(file_list, numeros_str):
    global state_images, state_parts
    # Procesa una lista de archivos de imágenes y una cadena de números
    imagenes = []
    captions = []

    try:
        # Cargar las imágenes
        for file in file_list:
            img = cv2.imread(file)
            if img is None:
                return [], f"Error al cargar imagen: {file}"

            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Convertir a RGB
            imagenes.append(img)

        # Convertir los números a enteros y luego a cadenas
        numeros = list(map(int, numeros_str.split(",")))
        captions = [str(num).strip() for num in numeros]  # Convertir números a cadenas

        # Asegurarse de que haya el mismo número de imágenes y captions
        if len(imagenes) != len(captions):
            return [], "El número de imágenes y números no coincide."

        state_images = list(zip(imagenes, captions))
        state_parts = [(img, None, -1) for img, _ in state_images]

        # Retornar las imágenes y los captions
        return state_images, "Carga exitosa"

    except ValueError:
        return [], "Error: Los números deben ser valores numéricos."
    except Exception as e:
        return [], f"Error inesperado: {e}"

# Predicción y cantidades

def predict_cat(imagen):
    # Predice una imagen cargada
    test_image = cv2.cvtColor(imagen, cv2.COLOR_BGR2RGB)
    test_image = cv2.resize(test_image, (720, 720), interpolation=cv2.INTER_AREA)
    test_image = np.expand_dims(test_image, axis=0)
    index = new_model.predict(test_image).argmax()
    return categorias[index]

def process_auto_predict():
    # Predice las imagenes del estado automaticamente

    global state_images, state_parts
    resultados = []

    for i, (imagen, num) in enumerate(state_images):
        prediccion = predict_cat(imagen)
        resultados.append(f"La imagen número {i+1} es una {prediccion}")
        state_parts[i] = (imagen, prediccion, num)

    return [item[0] for item in state_images], "\n".join(resultados)

def process_manual_predict(num_img, cat):
    # Predice las imagenes del estado manualmente

    global state_images, state_parts
    num_img = int(num_img) - 1

    if not (0 <= num_img < len(state_images)):
        return [], "Error inesperado: Número de imagen no válido"

    imagen, num = state_images[num_img]
    state_parts[num_img] = (imagen, cat, num)

    return [imagen], f"La imagen número {num_img+1} es una {cat}"

def toggle_sliders(sliders_visible):
    # Alterna la visibilidad de los sliders

    new_state = not sliders_visible
    return (gr.update(visible=new_state),) * 3 + (new_state,)

def mostrar_predicc():
    # Muestra las predicciones hechas

    global state_parts
    imgs = [img for img, _, _ in state_parts]
    resultados = [f"La imagen número {i+1} es una {pred}" for i, (_, pred, _) in enumerate(state_parts)]
    return imgs, "\n".join(resultados)

# Recetario

def obtener_piezas():
    # En un array escribe la cantidad de piezas del usuario dependiendo su categoría
    global state_parts
    return [
        sum(int(num) for _, cat, num in state_parts if cat == i and str(num).isdigit())
        for i in categorias
    ]

def search_recipe(tipo):
    # Devuelve las recetas acorde a las piezas disponibles

    global state_parts, diccionario_enlaces, diccionario_datos
    lista_numeros = obtener_piezas()

    recetas = filtrar_diccionario_por_numeros(lista_numeros,diccionario_datos) if tipo == "estricta" else filtrar_diccionario_por_numeros_laxa(lista_numeros,diccionario_datos)

    if not recetas:
        return [], f"No se han encontrado recetas con la búsqueda {tipo}."

    imgs = [abrir_imagen_desde_enlace(diccionario_enlaces[i]) for i in recetas]
    return imgs, f"Se han encontrado {len(imgs)} recetas."

# Configuración de la interfaz
def create_interface():
    with gr.Blocks() as demo:
        # Tab para cargar imágenes
        with gr.Tab("Recopilador de imágenes"):
            inputs = [
                gr.File(file_types=["image"], label="Cargar Imágenes", file_count="multiple"),
                gr.Textbox(label="Números asignados (separados por comas)", placeholder="Ejemplo: 2, 1, 3")
            ]
            outputs = [
                gr.Gallery(label="Imágenes", elem_id="output_gallery"),
                gr.Textbox(label="Estado de la carga")
            ]
            gr.Interface(
                fn=process_inputs,
                inputs=inputs,
                outputs=outputs,
                title="Ordenar Imágenes por Número",
                description=(
                    "Carga varias imágenes y asigna un número a cada una. "
                    "Escribe los números separados por comas en el mismo orden que las imágenes cargadas. "
                ),
                flagging_mode="never"
            )

        # Tab para predicción
        with gr.Tab("Predicción y cantidades"):
            gr.Markdown("Aquí puedes realizar predicciones automáticas o manuales sobre las categorías disponibles. Usa los botones y controles para interactuar con el sistema.")

            with gr.Row():
                with gr.Column():
                    gr.Markdown("### Predicción automática")
                    toggle_button = gr.Button("Predicción manual",variant= "secondary")
                    number_field = gr.Number(label="Número entero", value=1, visible=False, precision=0)
                    dropdown = gr.Dropdown(label="Categorías", choices=categorias, value="compuerta", visible=False)
                    process_button_MANUAL = gr.Button("Procesar MANUAL", visible=False,variant= "primary")
                    process_button = gr.Button("Procesar Automático",variant= "primary")
                    mostrar_predicciones=gr.Button("Mostrar predicciones", variant= "primary")
                with gr.Column():
                    gallery = gr.Gallery(label="Partes disponibles")
                    output = gr.Textbox(label="Resultado")

            sliders_state = gr.State(False)
            process_button_MANUAL.click(process_manual_predict, inputs=[number_field, dropdown],outputs=[gallery, output])
            toggle_button.click(toggle_sliders, inputs=sliders_state, outputs=[number_field, dropdown,process_button_MANUAL, sliders_state])
            process_button.click(process_auto_predict, outputs=[gallery, output])
            mostrar_predicciones.click(mostrar_predicc,outputs=[gallery, output])

        # Tab para el recetario
        with gr.Tab("Recetario"):
            gr.Markdown("Aquí puedes buscar formas para hacer con tus piezas. La búsqueda precisa usa las piezas exactas que tiene y la búsqueda laxa realiza sustituciones por piezas similares.")

            categoria_input = gr.Dropdown(label="Tipo de busqueda", choices=["estricta", "laxa"], value="estricta")
            search_button = gr.Button("Buscar en el recetario", variant="primary")
            recipe_gallery = gr.Gallery(label="Imágenes encontradas")
            recipe_output = gr.Textbox(label="Resultados de la búsqueda")

            search_button.click(search_recipe, inputs=categoria_input, outputs=[recipe_gallery, recipe_output])

    demo.launch(debug=True)

create_interface()